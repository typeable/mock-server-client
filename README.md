# About

The package is the client library for the [mock server](https://www.mock-server.com/). The source code is
generated by the [openapi3-code-generator](https://hackage.haskell.org/package/openapi3-code-generator), specifically its patched version.

## Usage

``` haskell
module Main

import MockServer as Mock
import Network.HTTP.Client

conf :: Mock.Configuration
conf = Configuration
  { configBaseURL = "http://localhost"
  , configSecurityScheme = id
  , configIncludeUserAgent = False
  , configApplicationName = "ping-app" }

expectation :: Mock.Expectations
expectation = Mock.ExpectationsExpectation $ Mock.mkExpectation
  { expectationHttpRequest = Just request
  , expectationHttpResponse = Just response }
  where
    request = Mock.mkHttpRequest
      { httpRequestMethod = Just $ StringOrJsonSchemaText "POST"
      , httpRequestPath = Just $ StringOrJsonSchemaText "/ping" }
    response = Mock.mkHttpResponse
      { httpResponseBody = Just $ BodyWithContentTypeRawStringResponseBody "pong"
      , httpResponseStatusCode = Just 200 }

-- | Puts the expectation which will response with "pong" body to the "POST /ping" request
main :: IO ()
main = do
  void $ Mock.runWithConfiguration conf $ Mock.put_mockserver_expectation expectation
```

# Maintainance

## Files

### The `codegen` dir

* `regen.sh` is the simple script to regenerate the whole package.
* `shell.nix` a shell in which the `regen.sh` calls the `openapi3-code-generator` to regenerate the
* `mock-server-openapi-5.13.x-swagger.yaml` not the original file as you might
  think. The thing is that the `openapi3-code-generator` does not support all
  the features of the OpenAPI3 standard correctly, so it is
  hand-postprocessed. It was originally downloaded from [here](https://app.swaggerhub.com/apis/jamesdbloom/mock-server-openapi/5.13.x) and fixed.

### Other

* `src` contails the generted code, but not exactly. Some of the parts of the
  generted code was not very pleasant, so it was fixed too.

## What will happen if you just call the `regen.sh`?

It will build the `openapi3-code-generator` in `nix` and regenerate the whole
Haskell source code. You will see that the code was changed, because as
mentioned earlier the original code was slightly modified, so watch your commits.

## How the to update the package to the new version of the `mock-server`?

* Commit all changes
* `git checkout update-openapi-spec`
* Replace the `codegen/mock-server-openapi.yaml` with a newer version
* `git commit -m "updated mock-server-openapi.yaml to version $NEWVERSION"`
* `git checkout -b "update-$NEWVERSION" master`
* `git merge update-openapi-spec`
* Resolve conflicts if any
* `./codegen/regen.sh`
* `git symbolic-ref HEAD refs/heads/update-generated-code && git reset`
  switching to the branch `update-generated-code` without checking out the working-tree
* `git commit -m "update the generted code for version $NEWVERSION"`
* `git checkout "update-$NEWVERSION"`
* `git merge update-generated-code`
* Resolve conflicts if any
* `git push origin "update-$NEWVERSION"`
* Create PR, wait for CI, review, merge into the master

The algorithm is kind of weird, but for a reason.

The branch `update-openapi-spec` is the branch tracking only original
`codegen/mock-server-openapi.yaml` changes, meaning changes made by authors of the
`mock-server`. So, when you merge changes of this branch into the master you literally merge the
changes made by authors of the `mock-server` with our manual changes made to please the
`openapi3-code-generator`.

The bratch `update-generated-code` is for tracking "changes" made by the code generator when it is
feed by the new OpenAPI spec file. So, when you merge this branch into the master you literally
merge the "code regeneration patch" with changes made by hand.

The `master` branch is for manual changes only. The changes made to keep things working and the
package usable. You can always see the manual changes just by `git diff update-generated-code
master` or `git diff update-openapi-spec master`
